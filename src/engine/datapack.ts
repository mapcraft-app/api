import { randomBytes } from 'crypto';
import { accessSync } from 'fs';
import { access, cp, mkdir, readFile, rm, writeFile } from 'fs/promises';
import { resolve } from 'path';
import download from 'misc/download';
import fetch from 'misc/fetch';

import { envInterface } from './interface';
import engine from './base';
import versions from 'src/minecraft/version';

export default class extends engine {
	private _path: { archive: string, custom: string, pack: string, temp: string };
	private release: { description: string, url: string, version: string } | undefined;
	private baseUrl: string;

	public instanceDownload: download | undefined;

	constructor(
		env: envInterface,
		name: string,
		version: '1.17' | '1.18' | '1.19' = '1.19'
	) {
		super(env, version, name);
		this.baseUrl = (process.env.DEV)
			? 'http://localhost:3000'
			: 'https://api.mapcraft.app';
		const randomId = randomBytes(16).toString('hex').slice(0, 16);
		this._path = {
			archive: resolve(this.env.temp, `mapcraft_${randomId}`, 'datapack.zip'),
			custom: resolve(this.path.datapack, 'datapacks', 'mapcraft-data'),
			pack: resolve(this.path.datapack, 'datapacks', 'mapcraft'),
			temp: resolve(this.env.temp, `mapcraft_${randomId}`)
		};
	}

	private async installGeneratedDatapack(): Promise<void> {
		const getFormat = (): number => {
			for (const el of versions) {
				if (el.version === this.version)
					return el.datapack;
			}
			return versions[0].datapack;
		};

		await mkdir(resolve(this._path.custom, 'data', 'mapcraft-data'), { recursive: true });
		await writeFile(
			resolve(this._path.custom, 'pack.mcmeta'),
			JSON.stringify({
				__mapcraft__: 'Datapack generated by Mapcraft software (http://mapcraft.app)',
				version: {
					minecraft: this.version,
					timestamp: Date.now()
				},
				pack: {
					pack_format: getFormat(),
					description: 'Mapcraft generate mcfunction'
				}
			}, null, 4),
			{ encoding: 'utf-8', flag: 'w' }
		);
	}

	private async installDefaultPack(): Promise<void> {
		try {
			accessSync(this._path.temp);
		} catch (___) {
			await mkdir(this._path.temp);
		}
		await rm(this._path.archive, { recursive: true, force: true });
		await rm(this._path.pack, { recursive: true, force: true });
		await mkdir(this._path.pack, { recursive: true });
		const data = (await fetch(`${this.baseUrl}/software/datapack/${this.version}`)).json();
		this.release = data.releases[0] as { description: string, url: string, version: string };
		this.instanceDownload = new download(this.release.url, this._path.archive);
		await this.instanceDownload?.get();
		return this.unpackData(this._path.archive, this._path.pack);
	}

	async install(): Promise<[void, void]> {
		try {
			accessSync(this._path.temp);
		} catch (___) {
			await mkdir(this._path.temp);
		}
		return Promise.all([
			this.installGeneratedDatapack(),
			this.installDefaultPack()
		]);
	}

	async update(): Promise<void> {
		await access(this._path.custom) // custom datapack
			.catch(async () => {
				await this.installGeneratedDatapack();
			});
		await access(this._path.pack) // default datapack
			.then(async () => {
				const localVersion = JSON.parse(await readFile(resolve(this._path.pack, 'pack.mcmeta'), { encoding: 'utf-8' })).mapcraft.version as string;
				const remoteVersion = (await fetch(`${this.baseUrl}/software/datapack/${this.version}`)).json().releases[0].version as string;
				if (localVersion !== remoteVersion)
					await this.installDefaultPack();
			})
			.catch(async () => {
				await this.installDefaultPack();
			});
	}

	async build(): Promise<string> {
		const tempDir = resolve(this.env.temp, `mapcraft_${randomBytes(16).toString('hex').slice(0, 16)}`);
		const builtInDir = resolve(tempDir, 'data', 'mapcraft', 'functions', 'built_in');

		await mkdir(tempDir, { recursive: true });
		await cp(this._path.pack, tempDir, { dereference: true, recursive: true });
		await rm(resolve(tempDir, 'data', 'temp_slot'), { recursive: true, force: true });
		await rm(resolve(tempDir, 'data', 'mapcraft', 'structures'), { recursive: true, force: true });
		await rm(resolve(tempDir, 'data', 'mapcraft', 'functions', 'tools'), { recursive: true, force: true });
		// built-in
		await rm(resolve(builtInDir, 'copy'), { recursive: true, force: true });
		await rm(resolve(builtInDir, 'cursor'), { recursive: true, force: true });
		await rm(resolve(builtInDir, 'fill'), { recursive: true, force: true });
		await rm(resolve(builtInDir, 'gui'), { recursive: true, force: true });
		await rm(resolve(builtInDir, 'paintbrush'), { recursive: true, force: true });
		await rm(resolve(builtInDir, 'selection'), { recursive: true, force: true });

		return tempDir;
	}

	check(): boolean {
		const custom = this._check(this._path.custom);
		const _default = this._check(this._path.pack);
		return (custom === true && _default === true);
	}

	clean(): Promise<void[]> {
		return Promise.all([
			rm(this.path.datapack, { force: true, recursive: true }),
			rm(this._path.temp, { force: true, recursive: true })
		]);
	}

	hashMap(write = false): Promise<Record<string, any>> {
		return this._generateHashMap(this.path.resourcepack, write);
	}
}
