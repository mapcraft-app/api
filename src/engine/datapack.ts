import { accessSync } from 'fs';
import { mkdir, rm, writeFile } from 'fs/promises';
import { resolve } from 'path';
import { unpack } from '7zip-min';
import download from 'misc/download';
import fetch from 'misc/fetch';

import { envInterface } from './interface';
import engine from './base';
import versions from 'src/minecraft/version';

export default class extends engine {
	private _path: { archive: string, custom: string, pack: string, temp: string };
	private release: { description: string, url: string, version: string } | undefined;

	public instanceDownload: download | undefined;

	constructor(
		env: envInterface,
		name: string,
		version: '1.17' | '1.18' | '1.19' = '1.19'
	) {
		super(env, version, name);
		this._path = {
			archive: resolve(this.env.temp, `mapcraft_${version}_dtp`, 'datapack.zip'),
			custom: resolve(this.path.datapack, 'datapacks', 'mapcraft-data'),
			pack: resolve(this.path.datapack, 'datapacks', 'mapcraft'),
			temp: resolve(this.env.temp, `mapcraft_${version}_dtp`)
		};
	}

	private async createCustomDatapack() {
		const getFormat = (): number => {
			for (const el of versions) {
				if (el.version === this.version)
					return el.datapack;
			}
			return versions[0].datapack;
		};

		await mkdir(resolve(this._path.custom, 'data', 'mapcraft-data'), { recursive: true });
		await writeFile(
			resolve(this._path.custom, 'pack.mcmeta'),
			JSON.stringify({
				__mapcraft__: 'Datapack generated by Mapcraft software (http://mapcraft.app)',
				version: {
					minecraft: this.version,
					timestamp: Date.now()
				},
				pack: {
					pack_format: getFormat(),
					description: 'Mapcraft generate mcfunction'
				}
			}, null, 2),
			{
				encoding: 'utf-8',
				flag: 'w'
			}
		);
	}

	private async fetchRelease() {
		const baseUrl = (process.env.DEV)
			? 'http://localhost:3000'
			: 'https://api.mapcraft.app';
		return fetch(`${baseUrl}/software/datapack/${this.version}`)
			.then((d) => d.json())
			.then((d) => {
				this.release = d.releases[0] as { description: string, url: string, version: string };
				this.instanceDownload = new download(this.release.url, this._path.archive);
			});
	}

	async install(): Promise<{ archive: string }> {
		try {
			accessSync(this._path.temp);
		} catch (___) {
			await mkdir(this._path.temp);
		}
		await this.createCustomDatapack();
		await this.fetchRelease();
		return new Promise((res, rej) => {
			this.instanceDownload?.get()
				.then(() => {
					unpack(this._path.archive, this._path.pack, (err) => {
						if (err)
							rej(err);
						res({ archive: this._path.archive });
					});
				});
		});
	}

	build(): Promise<string> {
		return this._build(this.path.datapack);
	}

	check(): boolean {
		return this._check(this.path.datapack);
	}

	clean(): Promise<void[]> {
		return Promise.all([
			rm(this.path.datapack, { force: true, recursive: true }),
			rm(this._path.temp, { force: true, recursive: true })
		]);
	}

	hashMap(write = false): Promise<Record<string, any>> {
		return this._generateHashMap(this.path.resourcepack, write);
	}
}
