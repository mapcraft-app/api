import { createHash, randomBytes } from 'crypto';
import { copyFile, cp, mkdir, readdir, readFile, stat, writeFile } from 'fs/promises';
import { resolve } from 'path';

import download from 'misc/download';
import { envInterface } from './interface';

export default class {
	protected env: envInterface;
	protected version: '1.17' | '1.18' | '1.19';
	protected directory: string;

	constructor(env: envInterface, version: '1.17' | '1.18' | '1.19' = '1.17', directory: string) {
		this.env = env;
		this.version = version;
		this.directory = directory;
	}

	private compareHash(original: Record<string, any>, modified: Record<string, any>): Record<string, any> {
		const ret: Record<string, any> = {};
		const compFunc = (obj1: Record<string, any>, obj2: Record<string, any>, data: Record<string, any>) => {
			for (const x in obj1) {
				if (Object.prototype.hasOwnProperty.call(obj1, x) && Object.prototype.hasOwnProperty.call(obj2, x)) {
					if (typeof obj1[x] === 'object') {
						data[x] = {};
						compFunc(obj1[x], obj2[x], data[x]);
						if (!Object.keys(data[x]).length)
							delete data[x];
					} else if (obj1[x] !== obj2[x])
						data[x] = obj2[x];
				}
			}
		};

		compFunc(original, modified, ret);
		return ret;
	}

	async build(): Promise<string> {
		await stat(resolve(this.directory, 'hash.json'));

		const dir = resolve(this.directory, randomBytes(16).toString('hex').slice(0, 16));
		const hashMap = await this.generateHashMap();
		const oldMap = JSON.parse(await readFile(resolve(this.directory, 'hash.json'), { encoding: 'utf-8', flag: 'r' }));
		const modifiedHash = this.compareHash(oldMap, hashMap);

		const cpFiles = async (orig: string, dest: string, obj: Record<string, any>) => {
			await mkdir(dest);
			for (const x in obj) {
				if (typeof obj[x] === 'object')
					await cpFiles(resolve(orig, x), resolve(dest, x), obj[x]);
				else
					await copyFile(resolve(orig, x), resolve(dest, x));
			}
		};

		await mkdir(dir);
		await mkdir(resolve(dir, 'assets'));
		const mcMeta: Record<string, any> = JSON.parse(await readFile(resolve(this.directory, 'pack.mcmeta'), { encoding: 'utf-8', flag: 'r' }));
		mcMeta['__mapcraft'] = 'This resource pack is generated by Mapcraft software';
		await writeFile(resolve(dir, 'pack.mcmeta'), JSON.stringify(mcMeta, null, 2), { encoding: 'utf-8', flag: 'w' });
		await copyFile(resolve(this.directory, 'pack.png'), resolve(dir, 'pack.png'));
		for (const x in modifiedHash.assets) {
			if (x === 'mapcraft')
				await cp(resolve(this.directory, 'assets', 'mapcraft'), resolve(dir, 'assets', 'mapcraft'), { recursive: true });
			else
				await cpFiles(resolve(this.directory, 'assets', x), resolve(dir, 'assets', x), modifiedHash.assets[x]);
		}
		return dir;
	}

	async generateHashMap(write = false): Promise<Record<string, any>> {
		const ret: Record<string, any> = {
			timestamp: new Date().toUTCString()
		};
		const recFunc = async (base: string, data: Record<string, any>) => {
			await readdir(base, { encoding: 'utf-8', withFileTypes: true })
				.then(async (dirs) => {
					for (const dir of dirs) {
						if (dir.isFile() && dir.name !== 'hash.json') {
							const hash = createHash('sha256');
							hash.update(await readFile(resolve(base, dir.name)));
							data[dir.name] = hash.digest('hex');
						}
						if (dir.isDirectory()) {
							data[dir.name] = {};
							await recFunc(resolve(base, dir.name), data[dir.name]);
						}
					}
				})
				.catch((e) => {
					throw Error(e);
				});
		};
	
		const testIsDir = await stat(this.directory);
		if (!testIsDir.isDirectory())
			throw new Error('Path is not a directory');
		await recFunc(this.directory, ret);
		if (write)
			writeFile(resolve(this.directory, 'hash.json'), JSON.stringify(ret), { encoding: 'utf-8', flag: 'w' });
		return ret;
	}
}
