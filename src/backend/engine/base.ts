import { createHash, randomBytes } from 'crypto';
import { accessSync } from 'fs';
import { copyFile, cp, mkdir, readdir, readFile, stat, writeFile } from 'fs/promises';
import { resolve } from 'path';
import { envInterface } from '@/types';
import sevenZip from '@/backend/7zip';
import version from '@/minecraft/version';
import type { minecraftVersion } from '@/types';

export default class {
	public env: envInterface;
	public version: minecraftVersion;
	public name: string;
	public path: { datapack: string, resourcepack: string };
	public hashStat: { current: number, total: number, percent: number };
	private sevenZip: sevenZip;
	
	constructor(env: envInterface, version: minecraftVersion, name: string) {
		this.env = env;
		this.version = version;
		this.name = name;
		this.path = {
			datapack: resolve(this.env.save, this.name),
			resourcepack: resolve(this.env.resource, this.name)
		};
		this.hashStat = { current: 0, total: 0, percent: 0 };
		this.sevenZip = new sevenZip();
	}

	protected unpackData(src: string, dest: string): Promise<Record<string, string>[]> {
		return this.sevenZip.unpack(src, dest);
	}

	protected compareHash(original: Record<string, any>, modified: Record<string, any>): Record<string, any> {
		const ret: Record<string, any> = {};
		const compFunc = (obj1: Record<string, any>, obj2: Record<string, any>, data: Record<string, any>) => {
			for (const x in obj1) {
				if (Object.prototype.hasOwnProperty.call(obj1, x) && Object.prototype.hasOwnProperty.call(obj2, x)) {
					if (typeof obj1[x] === 'object') {
						data[x] = {};
						compFunc(obj1[x], obj2[x], data[x]);
						if (!Object.keys(data[x]).length)
							delete data[x];
					} else if (obj1[x] !== obj2[x])
						data[x] = obj2[x];
				} else if (Object.prototype.hasOwnProperty.call(obj2, x)) {
					if (typeof obj2[x] === 'object') {
						data[x] = {};
						compFunc(obj1[x], obj2[x], data[x]);
						if (!Object.keys(data[x]).length)
							delete data[x];
					} else
						data[x] = obj2[x];
				}
			}
		};

		compFunc(original, modified, ret);
		return ret;
	}

	protected async _build(pathToDirectory: string, toDir: string | undefined = undefined): Promise<string> {
		await stat(resolve(pathToDirectory, 'hash.json'));

		const dir = toDir ?? resolve(pathToDirectory, randomBytes(16).toString('hex').slice(0, 16));
		const hashMap = await this._generateHashMap(pathToDirectory);
		const oldMap = JSON.parse(await readFile(resolve(pathToDirectory, 'hash.json'), { encoding: 'utf-8', flag: 'r' }));
		const modifiedHash = this.compareHash(oldMap, hashMap);

		const cpFiles = async (orig: string, dest: string, obj: Record<string, any>) => {
			await mkdir(dest);
			for (const x in obj) {
				if (typeof obj[x] === 'object')
					await cpFiles(resolve(orig, x), resolve(dest, x), obj[x]);
				else
					await copyFile(resolve(orig, x), resolve(dest, x));
			}
		};

		await mkdir(dir);
		await mkdir(resolve(dir, 'assets'));
		const mcMeta: Record<string, any> = JSON.parse(await readFile(resolve(pathToDirectory, 'pack.mcmeta'), { encoding: 'utf-8', flag: 'r' }));
		mcMeta['__mapcraft'] = 'This resource pack is generated by Mapcraft software';
		await writeFile(resolve(dir, 'pack.mcmeta'), JSON.stringify(mcMeta, null, 2), { encoding: 'utf-8', flag: 'w' });
		await copyFile(resolve(pathToDirectory, 'pack.png'), resolve(dir, 'pack.png'));
		for (const x in modifiedHash.assets) {
			if (x === 'mapcraft')
				await cp(resolve(pathToDirectory, 'assets', 'mapcraft'), resolve(dir, 'assets', 'mapcraft'), { recursive: true });
			else
				await cpFiles(resolve(pathToDirectory, 'assets', x), resolve(dir, 'assets', x), modifiedHash.assets[x]);
		}
		return dir;
	}

	_check(path: string): boolean {
		try {
			accessSync(path);
			accessSync(resolve(path, 'pack.mcmeta'));
			return true;
		} catch (___) {
			return false;
		}
	}

	async _generateHashMap(pathToDirectory: string, write = false): Promise<Record<string, any>> {
		const tempVersion = version.find((e) => e.version === this.version);
		const ret: Record<string, any> = {
			__mapcraft_info__: {
				creationDate: new Date().toUTCString(),
				version: tempVersion?.version ?? this.version,
				datapack: tempVersion?.datapack,
				resourcepack: tempVersion?.resourcepack 
			}
		};

		const countFileForHashMap = async (base: string) => {
			await readdir(base, { encoding: 'utf-8', withFileTypes: true })
				.then(async (dirs) => {
					for (const dir of dirs) {
						if (dir.isFile() && dir.name !== 'hash.json')
							++this.hashStat.total;
						if (dir.isDirectory())
							await countFileForHashMap(resolve(base, dir.name));
					}
				})
				.catch((e) => {
					throw Error(e);
				});
		};

		const recFunc = async (base: string, data: Record<string, any>) => {
			await readdir(base, { encoding: 'utf-8', withFileTypes: true })
				.then(async (dirs) => {
					for (const dir of dirs) {
						if (dir.isFile() && dir.name !== 'hash.json') {
							++this.hashStat.current;
							this.hashStat.percent = Math.round((this.hashStat.current / this.hashStat.total) * 100);
							data[dir.name] = createHash('sha256')
								.update(await readFile(resolve(base, dir.name)))
								.digest('hex');
						}
						if (dir.isDirectory()) {
							data[dir.name] = {};
							await recFunc(resolve(base, dir.name), data[dir.name]);
						}
					}
				})
				.catch((e) => {
					throw Error(e);
				});
		};
	
		this.hashStat = { current: 0, total: 0, percent: 0 };

		const testIsDir = await stat(pathToDirectory);
		if (!testIsDir.isDirectory())
			throw new Error('Path is not a directory');

		await countFileForHashMap(pathToDirectory);
		await recFunc(pathToDirectory, ret);

		if (write)
			writeFile(resolve(pathToDirectory, 'hash.json'), JSON.stringify(ret), { encoding: 'utf-8', flag: 'w' });

		return ret;
	}
}
